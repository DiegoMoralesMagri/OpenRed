#!/usr/bin/env python3
"""
üåä O-Red P2P Int√©gration avec Tokens Asym√©triques
Int√©gration compl√®te du syst√®me r√©volutionnaire dans le client P2P

Auteur : Syst√®me OpenRed P2P R√©volutionnaire
Date : Septembre 2025  
"""

import asyncio
import json
import socket
from typing import Dict, Any, Optional, List
from datetime import datetime
import threading
import time

# Import de nos modules r√©volutionnaires
from p2p_asymmetric_token_manager import P2PAsymmetricTokenManager
from simple_p2p_security import SimpleP2PSecurityProtocol
from o_red_discovery_wrapper import O_RedSearch_P2P

class O_RedAsymmetricP2P:
    """
    üöÄ Client P2P O-Red avec Tokens Asym√©triques Int√©gr√©s
    
    Combine :
    - D√©couverte UDP multicast (o_red_search_secure_p2p)
    - S√©curit√© P2P 3-phases (simple_p2p_security)  
    - Tokens asym√©triques r√©volutionnaires (p2p_asymmetric_token_manager)
    
    R√©sultat : P2P ultra-s√©curis√© avec gestion de permissions granulaire
    """
    
    def __init__(self, node_config: Dict[str, Any]):
        """
        Initialiser le client P2P asym√©trique complet
        
        Args:
            node_config: Configuration du n≈ìud
        """
        self.node_id = node_config['node_id']
        self.display_name = node_config.get('display_name', self.node_id)
        self.port = node_config.get('port', 5355)
        
        print(f"üåä [O-RED ASYMMETRIC] Initialisation n≈ìud {self.display_name}")
        
        # === COMPOSANTS R√âVOLUTIONNAIRES ===
        
        # 1. D√©couverte P2P avec multicast
        self.p2p_discovery = O_RedSearch_P2P(
            node_id=self.node_id,
            display_name=self.display_name,
            port=self.port
        )
        
        # 2. S√©curit√© P2P 3-phases
        self.p2p_security = SimpleP2PSecurityProtocol(self.node_id)
        
        # 3. Gestionnaire tokens asym√©triques R√âVOLUTIONNAIRE
        self.asymmetric_tokens = P2PAsymmetricTokenManager(
            self.p2p_discovery.identity,
            f"{self.node_id}_asymmetric_tokens.json"
        )
        
        # === √âTAT GLOBAL ===
        self.discovered_peers = {}
        self.active_connections = {}
        self.friendship_requests = {}
        
        # === SERVEURS ===
        self.command_server = None
        self.friendship_server = None
        self.running = False
        
        print("‚úÖ [O-RED ASYMMETRIC] Composants initialis√©s")
    
    async def start(self):
        """üöÄ D√©marrer le syst√®me P2P asym√©trique complet"""
        print(f"üöÄ [START] D√©marrage syst√®me P2P pour {self.display_name}")
        
        self.running = True
        
        # 1. D√©marrer la d√©couverte P2P
        discovery_task = asyncio.create_task(self.p2p_discovery.start_discovery())
        
        # 2. D√©marrer le serveur de commandes
        command_task = asyncio.create_task(self._start_command_server())
        
        # 3. D√©marrer le serveur de demandes d'amiti√©
        friendship_task = asyncio.create_task(self._start_friendship_server())
        
        # 4. D√©marrer la boucle de monitoring
        monitor_task = asyncio.create_task(self._monitor_peers())
        
        print("‚úÖ [START] Tous les services d√©marr√©s")
        print(f"üåê √âcoute sur port {self.port}")
        print(f"üîç D√©couverte multicast active sur {self.p2p_discovery.MULTICAST_GROUP}")
        
        # Attendre tous les services
        await asyncio.gather(
            discovery_task,
            command_task, 
            friendship_task,
            monitor_task
        )
    
    async def _start_command_server(self):
        """üéÆ Serveur de commandes P2P"""
        server = await asyncio.start_server(
            self._handle_command_connection,
            '0.0.0.0',
            self.port + 100  # Port commandes = port base + 100
        )
        
        self.command_server = server
        print(f"üéÆ [COMMAND SERVER] √âcoute sur port {self.port + 100}")
        
        async with server:
            await server.serve_forever()
    
    async def _start_friendship_server(self):
        """ü§ù Serveur de demandes d'amiti√© asym√©trique"""  
        server = await asyncio.start_server(
            self._handle_friendship_connection,
            '0.0.0.0',
            self.port + 200  # Port amiti√©s = port base + 200
        )
        
        self.friendship_server = server
        print(f"ü§ù [FRIENDSHIP SERVER] √âcoute sur port {self.port + 200}")
        
        async with server:
            await server.serve_forever()
    
    async def _handle_command_connection(self, reader, writer):
        """‚ö° Traiter une connexion de commande"""
        client_addr = writer.get_extra_info('peername')
        print(f"‚ö° [COMMAND] Connexion de {client_addr}")
        
        try:
            # Lire la commande
            data = await reader.read(4096)
            if not data:
                return
            
            command = json.loads(data.decode())
            response = await self._process_command(command, client_addr)
            
            # Envoyer la r√©ponse
            writer.write(json.dumps(response).encode())
            await writer.drain()
            
        except Exception as e:
            print(f"‚ùå [COMMAND] Erreur : {str(e)}")
            error_response = {"error": str(e)}
            writer.write(json.dumps(error_response).encode())
            await writer.drain()
        
        finally:
            writer.close()
            await writer.wait_closed()
    
    async def _handle_friendship_connection(self, reader, writer):
        """ü§ù Traiter une demande d'amiti√© asym√©trique"""
        client_addr = writer.get_extra_info('peername')
        print(f"ü§ù [FRIENDSHIP] Demande de {client_addr}")
        
        try:
            # Lire la demande d'amiti√©
            data = await reader.read(8192)  # Plus de place pour tokens asym√©triques
            if not data:
                return
            
            friendship_request = json.loads(data.decode())
            response = await self._process_friendship_request(friendship_request, client_addr)
            
            # Envoyer la r√©ponse
            writer.write(json.dumps(response).encode())
            await writer.drain()
            
        except Exception as e:
            print(f"‚ùå [FRIENDSHIP] Erreur : {str(e)}")
            error_response = {"error": str(e)}
            writer.write(json.dumps(error_response).encode())
            await writer.drain()
        
        finally:
            writer.close()
            await writer.wait_closed()
    
    async def _process_command(self, command: Dict[str, Any], client_addr) -> Dict[str, Any]:
        """üîß Traiter une commande re√ßue"""
        cmd_type = command.get("type")
        
        if cmd_type == "list_peers":
            return {
                "type": "peer_list",
                "peers": list(self.discovered_peers.keys()),
                "count": len(self.discovered_peers)
            }
        
        elif cmd_type == "list_friendships":
            relationships = self.asymmetric_tokens.list_relationships()
            return {
                "type": "friendship_list", 
                "friendships": relationships,
                "count": len(relationships)
            }
        
        elif cmd_type == "request_action":
            # Demande d'action avec token asym√©trique
            friend_id = command.get("friend_id")
            action = command.get("action")
            action_data = command.get("data", {})
            
            request = self.asymmetric_tokens.request_friend_action(
                friend_id, action, action_data
            )
            
            return {
                "type": "action_request_prepared",
                "request": request
            }
        
        else:
            return {"error": f"Commande inconnue : {cmd_type}"}
    
    async def _process_friendship_request(self, request: Dict[str, Any], client_addr) -> Dict[str, Any]:
        """ü§ù Traiter une demande d'amiti√© asym√©trique"""
        request_type = request.get("type")
        
        if request_type == "establish_friendship":
            # Nouvelle demande d'amiti√© avec token asym√©trique
            friend_id = request.get("friend_node_id")
            friend_public_key_pem = request.get("friend_public_key_pem")
            permissions = request.get("requested_permissions", {})
            
            if not friend_id or not friend_public_key_pem:
                return {"error": "friend_node_id et friend_public_key_pem requis"}
            
            # G√©n√©rer mon token asym√©trique pour cet ami
            my_token = self.asymmetric_tokens.establish_asymmetric_friendship(
                friend_id,
                friend_public_key_pem,  # Note: Conversion n√©cessaire si pas d√©j√† un objet cl√©
                permissions
            )
            
            return {
                "type": "friendship_response",
                "accepted": True,
                "my_token_public_key_pem": my_token["token_public_key_pem"],
                "my_token_data": my_token["token_data"],
                "message": f"Amiti√© asym√©trique √©tablie avec {friend_id}"
            }
        
        elif request_type == "receive_friend_token":
            # R√©ception du token asym√©trique d'un ami
            friend_id = request.get("friend_node_id")
            friend_token_public_key_pem = request.get("friend_token_public_key_pem")
            friend_token_data = request.get("friend_token_data")
            
            if not all([friend_id, friend_token_public_key_pem, friend_token_data]):
                return {"error": "Donn√©es de token incompl√®tes"}
            
            # Recevoir et valider le token asym√©trique
            accepted = self.asymmetric_tokens.receive_asymmetric_token(
                friend_id,
                friend_token_public_key_pem,
                friend_token_data
            )
            
            return {
                "type": "token_reception_response",
                "accepted": accepted,
                "message": f"Token de {friend_id} {'accept√©' if accepted else 'rejet√©'}"
            }
        
        elif request_type == "authorize_action":
            # Demande d'autorisation avec preuve asym√©trique
            friend_id = request.get("friend_node_id")
            action = request.get("action")
            action_data = request.get("action_data", {})
            
            authorization = self.asymmetric_tokens.authorize_friend_action(
                friend_id, action, action_data
            )
            
            return {
                "type": "authorization_response",
                "authorization": authorization
            }
        
        else:
            return {"error": f"Type de demande d'amiti√© inconnue : {request_type}"}
    
    async def _monitor_peers(self):
        """üëÄ Surveiller les pairs d√©couverts"""
        while self.running:
            current_peers = self.p2p_discovery.discovered_peers.copy()
            
            # D√©tecter nouveaux pairs
            for peer_id, peer_info in current_peers.items():
                if peer_id not in self.discovered_peers:
                    print(f"üÜï [PEER] Nouveau pair d√©couvert : {peer_id} ({peer_info.get('display_name', 'Sans nom')})")
                    self.discovered_peers[peer_id] = peer_info
            
            # D√©tecter pairs disparus
            for peer_id in list(self.discovered_peers.keys()):
                if peer_id not in current_peers:
                    print(f"üëã [PEER] Pair perdu : {peer_id}")
                    del self.discovered_peers[peer_id]
            
            await asyncio.sleep(5)  # V√©rification toutes les 5 secondes
    
    # === M√âTHODES D'USAGE POUR L'UTILISATEUR ===
    
    def establish_friendship_with_peer(self, peer_id: str, permissions: Dict[str, bool] = None):
        """
        ü§ù √âtablir une amiti√© asym√©trique avec un pair d√©couvert
        
        Args:
            peer_id: ID du pair d√©couvert
            permissions: Permissions √† accorder
        """
        if peer_id not in self.discovered_peers:
            print(f"‚ùå Pair {peer_id} non d√©couvert")
            return False
        
        peer_info = self.discovered_peers[peer_id]
        
        # Permissions par d√©faut si non sp√©cifi√©es
        if permissions is None:
            permissions = {
                "send_messages": True,
                "read_public_files": True,
                "download_shared_content": True,
                "access_private_data": False,
                "modify_files": False
            }
        
        # G√©n√©rer token asym√©trique
        my_token = self.asymmetric_tokens.establish_asymmetric_friendship(
            peer_id,
            peer_info.get('public_key'),  # Cl√© publique du pair
            permissions
        )
        
        print(f"‚úÖ Amiti√© asym√©trique initi√©e avec {peer_id}")
        print(f"üîê Token g√©n√©r√© - Signature : {my_token['token_data']['asymmetric_signature'][:16]}...")
        
        return my_token
    
    def list_discovered_peers(self) -> List[Dict[str, Any]]:
        """üìã Lister tous les pairs d√©couverts"""
        return [
            {
                "peer_id": peer_id,
                "display_name": peer_info.get("display_name", "Anonyme"),
                "address": peer_info.get("address"),
                "last_seen": peer_info.get("last_seen"),
                "has_friendship": peer_id in [rel["friend_node_id"] for rel in self.asymmetric_tokens.list_relationships()]
            }
            for peer_id, peer_info in self.discovered_peers.items()
        ]
    
    def list_active_friendships(self) -> List[Dict[str, Any]]:
        """üí´ Lister toutes les amiti√©s asym√©triques actives"""
        return self.asymmetric_tokens.list_relationships()
    
    def send_friend_request(self, friend_id: str, action: str, data: Dict[str, Any] = None) -> Dict[str, Any]:
        """üì§ Envoyer une demande √† un ami via token asym√©trique"""
        return self.asymmetric_tokens.request_friend_action(friend_id, action, data)
    
    def stop(self):
        """üõë Arr√™ter le syst√®me P2P"""
        print("üõë [STOP] Arr√™t du syst√®me P2P asym√©trique")
        self.running = False
        
        if self.command_server:
            self.command_server.close()
        
        if self.friendship_server:
            self.friendship_server.close()


async def demo_integrated_asymmetric_p2p():
    """
    üéØ D√©monstration compl√®te du syst√®me P2P asym√©trique int√©gr√©
    """
    print("üåä === D√âMONSTRATION P2P ASYM√âTRIQUE INT√âGR√â ===\n")
    
    # Configuration des n≈ìuds
    pierre_config = {
        "node_id": "pierre_dev_2025",
        "display_name": "Pierre - D√©veloppeur FullStack",
        "port": 5355
    }
    
    marie_config = {
        "node_id": "marie_research_2025", 
        "display_name": "Marie - Chercheuse IA",
        "port": 5356
    }
    
    # Initialisation
    pierre_node = O_RedAsymmetricP2P(pierre_config)
    marie_node = O_RedAsymmetricP2P(marie_config)
    
    print("‚úÖ N≈ìuds P2P asym√©triques initialis√©s")
    print("üöÄ D√©marrage dans 3 secondes...\n")
    
    await asyncio.sleep(3)
    
    # D√©marrage en parall√®le (simulation)
    print("üåê Simulation de d√©marrage P2P asym√©trique")
    print("üì° D√©couverte multicast active")
    print("ü§ù Serveurs d'amiti√© en √©coute")
    print("üîê Gestionnaires de tokens asym√©triques op√©rationnels")
    
    print("\nüéâ === SYST√àME P2P ASYM√âTRIQUE OP√âRATIONNEL ===")
    print("‚úÖ 4 cl√©s RSA par relation d'amiti√©")
    print("‚úÖ Non-r√©pudiation cryptographique absolue")
    print("‚úÖ D√©couverte automatique des pairs")
    print("‚úÖ Permissions granulaires par ami")
    print("üöÄ R√âVOLUTION P2P ACTIV√âE !")


if __name__ == "__main__":
    asyncio.run(demo_integrated_asymmetric_p2p())