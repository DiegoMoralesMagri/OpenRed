#!/usr/bin/env python3
"""
üåç CONFIGURATEUR ACC√àS MONDIAL - FORT OPENRED
============================================

Configure l'acc√®s mondial pour un fort OpenRed via IP publique
et publication dans le r√©seau P2P d√©centralis√©.

√âtapes :
1. D√©tection IP publique automatique
2. Configuration routeur (instructions)
3. Publication r√©seau P2P mondial
4. Test accessibilit√© externe
"""

import os
import sys
import json
import socket
import requests
import threading
import time
from typing import Dict, Optional
from datetime import datetime

# Import des modules OpenRed
sys.path.append(os.path.join(os.getcwd(), 'modules'))
from persistance.gestionnaire_fort import GestionnairePersistanceFort
from internet.resolveur_p2p_decentralise import publier_fort


class ConfigurateurAccesMondial:
    """Configure l'acc√®s mondial pour un fort OpenRed"""
    
    def __init__(self):
        self.ip_publique = None
        self.port_externe = None
        self.fort_info = None
        
    def detecter_ip_publique(self) -> Optional[str]:
        """D√©tecte l'IP publique via services ind√©pendants"""
        print("üîç D√©tection de votre IP publique...")
        
        services = [
            "https://api.ipify.org",
            "https://ifconfig.me/ip", 
            "https://ipecho.net/plain",
            "https://checkip.dyndns.org"
        ]
        
        for service in services:
            try:
                print(f"   üåê Test {service}...")
                response = requests.get(service, timeout=5)
                
                if response.status_code == 200:
                    ip_text = response.text.strip()
                    
                    # Pour checkip.dyndns.org qui retourne du HTML
                    if "checkip.dyndns.org" in service:
                        import re
                        match = re.search(r'(\d+\.\d+\.\d+\.\d+)', ip_text)
                        if match:
                            ip_text = match.group(1)
                    
                    # Valide que c'est une IP
                    parts = ip_text.split('.')
                    if len(parts) == 4 and all(part.isdigit() and 0 <= int(part) <= 255 for part in parts):
                        self.ip_publique = ip_text
                        print(f"‚úÖ IP publique d√©tect√©e: {self.ip_publique}")
                        return self.ip_publique
                        
            except Exception as e:
                print(f"   ‚ö†Ô∏è  {service} injoignable: {e}")
                continue
        
        print("‚ùå Impossible de d√©tecter l'IP publique automatiquement")
        return None
    
    def tester_port_ouvert(self, port: int) -> bool:
        """Test si un port est accessible depuis l'ext√©rieur"""
        if not self.ip_publique:
            return False
            
        print(f"üîç Test accessibilit√© port {port} depuis l'ext√©rieur...")
        
        try:
            # Service de test de port (service tiers)
            test_url = f"http://portquiz.net:{port}"
            response = requests.get(test_url, timeout=10)
            
            if response.status_code == 200:
                print(f"‚úÖ Port {port} accessible depuis l'ext√©rieur")
                return True
            else:
                print(f"‚ùå Port {port} non accessible depuis l'ext√©rieur")
                return False
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Impossible de tester le port {port}: {e}")
            return False
    
    def generer_instructions_routeur(self, port: int) -> Dict:
        """G√©n√®re les instructions de configuration routeur"""
        instructions = {
            "titre": "üåç CONFIGURATION ROUTEUR POUR ACC√àS MONDIAL",
            "ip_publique": self.ip_publique,
            "port": port,
            "etapes": [
                {
                    "numero": 1,
                    "titre": "Acc√©der √† l'interface routeur",
                    "description": "Ouvrez l'interface web de votre routeur",
                    "actions": [
                        "Ouvrir navigateur web",
                        "Aller √† http://192.168.1.1 ou http://192.168.0.1",
                        "Se connecter avec identifiants administrateur",
                        "Chercher section 'Redirection de port' ou 'Port Forwarding'"
                    ]
                },
                {
                    "numero": 2,
                    "titre": "Configurer la redirection de port",
                    "description": f"Rediriger le port {port} vers votre machine",
                    "actions": [
                        f"Port externe: {port}",
                        f"IP interne: {self._detecter_ip_locale()}",
                        f"Port interne: {port}",
                        "Protocole: TCP",
                        "Nom de r√®gle: OpenRed Fort",
                        "Activer la r√®gle"
                    ]
                },
                {
                    "numero": 3,
                    "titre": "Configurer le pare-feu",
                    "description": "Autoriser le trafic sur le port",
                    "actions": [
                        f"Autoriser port {port} en entr√©e (TCP)",
                        "Cr√©er exception Windows Firewall si n√©cessaire",
                        "Red√©marrer routeur si demand√©"
                    ]
                },
                {
                    "numero": 4,
                    "titre": "Tester l'accessibilit√©",
                    "description": "V√©rifier que le fort est accessible",
                    "actions": [
                        f"Test depuis autre r√©seau: http://{self.ip_publique}:{port}",
                        "Utiliser site test de port (portchecker.co)",
                        "Demander √† un ami de tester l'acc√®s"
                    ]
                }
            ],
            "urls_test": [
                f"http://{self.ip_publique}:{port}",
                f"orp://fort_[ID].openred/",
                "https://www.portchecker.co",
                "https://canyouseeme.org"
            ],
            "notes_importantes": [
                "‚ö†Ô∏è  La configuration varie selon le mod√®le de routeur",
                "üîí V√©rifiez que le port est bien s√©curis√© (OpenRed uniquement)",
                "üåê L'IP publique peut changer (IP dynamique)",
                "üìû Contactez votre FAI si probl√®me persistant",
                "üîÑ Red√©marrage routeur parfois n√©cessaire"
            ]
        }
        
        return instructions
    
    def _detecter_ip_locale(self) -> str:
        """D√©tecte l'IP locale de la machine"""
        try:
            # M√©thode fiable pour obtenir l'IP locale
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.connect(("8.8.8.8", 80))
            ip_locale = sock.getsockname()[0]
            sock.close()
            return ip_locale
        except:
            return "192.168.1.100"  # Valeur par d√©faut
    
    def publier_fort_mondial(self, fort_id: str, nom_fort: str, port: int):
        """Publie le fort dans le r√©seau P2P mondial"""
        if not self.ip_publique:
            print("‚ùå IP publique requise pour publication mondiale")
            return False
        
        print(f"üì° Publication mondiale du fort {nom_fort}...")
        
        self.fort_info = {
            "fort_id": fort_id,
            "nom": nom_fort,
            "ip_publique": self.ip_publique,
            "port": port,
            "cle_publique": f"demo_key_{fort_id[:16]}",
            "timestamp": time.time(),
            "access_type": "mondial",
            "description": f"Fort OpenRed {nom_fort} accessible mondialement"
        }
        
        try:
            # Sauvegarde locale d'abord
            self._sauvegarder_registry_mondial()
            
            # Publication P2P
            publier_fort(self.fort_info)
            
            print(f"‚úÖ Fort publi√© mondialement !")
            print(f"üåç Accessible via: http://{self.ip_publique}:{port}")
            print(f"üîó URL OpenRed: orp://{fort_id}.openred/")
            
            return True
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur publication P2P: {e}")
            print("üíæ Fort sauvegard√© localement")
            return False
    
    def _sauvegarder_registry_mondial(self):
        """Sauvegarde le registry mondial local"""
        fichier_registry = "registry_mondial.json"
        
        # Charge le registry existant
        registry = {"forts_mondiaux": [], "meta": {}}
        if os.path.exists(fichier_registry):
            try:
                with open(fichier_registry, 'r', encoding='utf-8') as f:
                    registry = json.load(f)
            except:
                pass
        
        # Met √† jour les m√©tadonn√©es
        registry["meta"] = {
            "ip_publique": self.ip_publique,
            "derniere_maj": datetime.now().isoformat(),
            "type": "registry_mondial_openred",
            "version": "1.0"
        }
        
        # Ajoute ou met √† jour le fort
        found = False
        for i, fort in enumerate(registry["forts_mondiaux"]):
            if fort["fort_id"] == self.fort_info["fort_id"]:
                registry["forts_mondiaux"][i] = self.fort_info
                found = True
                break
        
        if not found:
            registry["forts_mondiaux"].append(self.fort_info)
        
        # Sauvegarde
        try:
            with open(fichier_registry, 'w', encoding='utf-8') as f:
                json.dump(registry, f, indent=2, ensure_ascii=False)
            
            print(f"üíæ Registry mondial sauvegard√©: {fichier_registry}")
            
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde registry: {e}")
    
    def generer_guide_acces_mondial(self, fort_id: str, nom_fort: str, port: int) -> str:
        """G√©n√®re un guide complet d'acc√®s mondial"""
        guide = f"""
# üåç GUIDE ACC√àS MONDIAL - FORT {nom_fort.upper()}

## üìã INFORMATIONS FORT

- **Nom:** {nom_fort}
- **Fort ID:** {fort_id}
- **IP Publique:** {self.ip_publique}
- **Port:** {port}

## üîó URLS D'ACC√àS

### Acc√®s Direct HTTP
```
http://{self.ip_publique}:{port}
```

### Acc√®s via Protocole OpenRed
```
orp://{fort_id}.openred/
```

## üåê ACC√àS DEPUIS N'IMPORTE O√ô DANS LE MONDE

### 1. Via Navigateur Web Classique
- Tapez: `http://{self.ip_publique}:{port}`
- Fonctionne depuis n'importe quel navigateur
- Acc√®s direct via Internet

### 2. Via Extension OpenRed (Recommand√©)
- Installer extension navigateur OpenRed
- Tapez: `orp://{fort_id}.openred/`
- R√©solution automatique P2P

### 3. Via R√©seau P2P OpenRed
- Autres forts OpenRed trouvent automatiquement
- D√©couverte via DHT distribu√©
- Acc√®s d√©centralis√©

## ‚öôÔ∏è CONFIGURATION REQUISE

### C√¥t√© Serveur (Vous)
‚úÖ Fort OpenRed d√©marr√© sur port {port}
‚úÖ IP publique d√©tect√©e: {self.ip_publique}
‚ö†Ô∏è  Redirection port routeur √† configurer
‚ö†Ô∏è  Pare-feu √† configurer

### C√¥t√© Client (Visiteurs)
‚úÖ Navigateur web standard (HTTP)
üîÑ Extension OpenRed (protocole orp://)
üîÑ Client OpenRed (acc√®s P2P avanc√©)

## üîß PROCHAINES √âTAPES

1. **Configurer votre routeur** (voir instructions d√©taill√©es)
2. **Tester l'acc√®s externe** 
3. **Partager votre URL fort**
4. **Surveiller les connexions**

## üìû PARTAGE DU FORT

Partagez ces URLs avec vos amis/coll√®gues :

**URL Directe (tous navigateurs):**
`http://{self.ip_publique}:{port}`

**URL OpenRed (avec extension):**
`orp://{fort_id}.openred/`

## üîí S√âCURIT√â

- ‚úÖ Chiffrement P2P natif OpenRed
- ‚úÖ Identit√© cryptographique unique
- ‚ö†Ô∏è  Port expos√© sur Internet (normal)
- üí° Surveiller les logs d'acc√®s

---
*Fort cr√©√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')}*
"""
        
        return guide
    
    def configurer_fort_existant(self, nom_fort: str = None) -> bool:
        """Configure un fort existant pour l'acc√®s mondial"""
        print("üåç === CONFIGURATION ACC√àS MONDIAL ===")
        
        # Charge le fort existant
        gestionnaire = GestionnairePersistanceFort()
        
        if nom_fort:
            identite = gestionnaire.creer_ou_charger_identite(nom_fort)
        else:
            # Essaie de charger le dernier fort
            identite = gestionnaire.charger_identite()
            if not identite:
                print("‚ùå Aucun fort trouv√©. Cr√©ez d'abord un fort.")
                return False
        
        print(f"‚úÖ Fort trouv√©: {identite.nom} ({identite.fort_id})")
        
        # D√©tecte l'IP publique
        if not self.detecter_ip_publique():
            print("‚ùå Configuration impossible sans IP publique")
            return False
        
        # G√©n√®re les instructions
        instructions = self.generer_instructions_routeur(identite.port)
        
        # Sauvegarde les instructions
        fichier_instructions = f"instructions_acces_mondial_{identite.fort_id[:8]}.json"
        try:
            with open(fichier_instructions, 'w', encoding='utf-8') as f:
                json.dump(instructions, f, indent=2, ensure_ascii=False)
            print(f"üìÑ Instructions sauvegard√©es: {fichier_instructions}")
        except:
            pass
        
        # Affiche les instructions
        print("\n" + "="*60)
        print("üîß INSTRUCTIONS CONFIGURATION ROUTEUR")
        print("="*60)
        
        for etape in instructions["etapes"]:
            print(f"\n{etape['numero']}Ô∏è‚É£ {etape['titre']}")
            print(f"   {etape['description']}")
            for action in etape['actions']:
                print(f"   ‚Ä¢ {action}")
        
        # Publication mondiale
        if input(f"\nüåç Publier le fort mondialement ? (o/N): ").lower().startswith('o'):
            success = self.publier_fort_mondial(
                identite.fort_id,
                identite.nom, 
                identite.port
            )
            
            if success:
                # G√©n√®re le guide d'acc√®s
                guide = self.generer_guide_acces_mondial(
                    identite.fort_id,
                    identite.nom,
                    identite.port
                )
                
                # Sauvegarde le guide
                fichier_guide = f"guide_acces_mondial_{identite.nom.replace(' ', '_')}.md"
                try:
                    with open(fichier_guide, 'w', encoding='utf-8') as f:
                        f.write(guide)
                    print(f"üìñ Guide d'acc√®s sauvegard√©: {fichier_guide}")
                except:
                    pass
        
        print("\n" + "="*60)
        print("üéâ CONFIGURATION ACC√àS MONDIAL TERMIN√âE")
        print("="*60)
        print(f"üåç URL mondiale: http://{self.ip_publique}:{identite.port}")
        print(f"üîó URL OpenRed: orp://{identite.fort_id}.openred/")
        print("\nüí° Suivez les instructions pour configurer votre routeur !")
        
        return True


def main():
    """Fonction principale"""
    configurateur = ConfigurateurAccesMondial()
    
    print("üåç === CONFIGURATEUR ACC√àS MONDIAL OPENRED ===")
    print("Rend votre fort accessible depuis n'importe o√π dans le monde")
    print("="*60)
    
    # Menu
    print("\nüéØ OPTIONS:")
    print("1. Configurer fort existant pour acc√®s mondial")
    print("2. D√©tecter IP publique seulement")
    print("3. G√©n√©rer instructions routeur")
    
    choix = input("\nVotre choix (1-3): ").strip()
    
    if choix == "1":
        nom_fort = input("Nom du fort (ou Entr√©e pour le dernier): ").strip()
        configurateur.configurer_fort_existant(nom_fort if nom_fort else None)
    
    elif choix == "2":
        configurateur.detecter_ip_publique()
    
    elif choix == "3":
        ip = input("Votre IP publique: ").strip()
        port = int(input("Port du fort: ").strip() or "8080")
        configurateur.ip_publique = ip
        instructions = configurateur.generer_instructions_routeur(port)
        
        print("\nüìã INSTRUCTIONS ROUTEUR:")
        for etape in instructions["etapes"]:
            print(f"\n{etape['numero']}Ô∏è‚É£ {etape['titre']}")
            for action in etape['actions']:
                print(f"   ‚Ä¢ {action}")
    
    else:
        print("‚ùå Choix invalide")


if __name__ == "__main__":
    main()