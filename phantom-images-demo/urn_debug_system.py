#!/usr/bin/env python3
"""
URN SYSTEM DEBUG & PHANTOM INTEGRATION
=====================================
Version de debug pour diagnostiquer les probl√®mes de sauvegarde
+ Int√©gration am√©lior√©e avec le syst√®me PHANTOM
"""

import os
import json
import hashlib
import secrets
from typing import Dict, List, Tuple, Optional, Any
from PIL import Image
import numpy as np
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend
import base64
import time
import logging
from dataclasses import dataclass, asdict
from pathlib import Path
import threading

# Configuration logging avec plus de d√©tails
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class AshFragment:
    """Fragment de cendre - un pixel crypt√©"""
    color_rgb: Tuple[int, int, int]
    position: Tuple[int, int]  # (x, y)
    next_fragment_name: str
    next_decrypt_key: bytes
    creation_timestamp: float

@dataclass
class UrnConfig:
    """Configuration d'une urne"""
    image_hash: str
    total_fragments: int
    image_dimensions: Tuple[int, int]
    creation_time: float
    authorized_node: str
    burn_after_reads: int = 1

class PhantomUrnDebug:
    """Version debug de PhantomUrn avec logs d√©taill√©s"""
    
    def __init__(self, urn_directory: str):
        self.urn_dir = Path(urn_directory)
        print(f"üîß DEBUG: Initialisation URN dans: {self.urn_dir}")
        
        # Cr√©er le r√©pertoire avec v√©rification
        try:
            self.urn_dir.mkdir(exist_ok=True, parents=True)
            print(f"‚úÖ DEBUG: R√©pertoire cr√©√©/v√©rifi√©: {self.urn_dir}")
            print(f"üìÇ DEBUG: Permissions r√©pertoire: {oct(os.stat(self.urn_dir).st_mode)[-3:]}")
        except Exception as e:
            print(f"‚ùå DEBUG: Erreur cr√©ation r√©pertoire: {e}")
            raise
        
        # Cl√©s asym√©triques
        self.activation_private_key = None
        self.activation_public_key = None
        
        # Configuration
        self.config: Optional[UrnConfig] = None
        self.fragments_map: Dict[str, str] = {}
        
        # √âtat runtime
        self.is_active = False
        self.phoenix_matrix: Optional[np.ndarray] = None
        
    def burn_image(self, image_path: str, authorized_node: str = "node_A") -> Dict[str, Any]:
        """Combustion avec debug d√©taill√©"""
        print(f"üî• DEBUG: D√©but combustion de {image_path}")
        
        try:
            # Charger image
            image = Image.open(image_path).convert('RGB')
            print(f"üìä DEBUG: Image charg√©e: {image.size}, mode: {image.mode}")
            
            # G√©n√©rer cl√©s d'activation
            self._generate_activation_keys()
            print("üîë DEBUG: Cl√©s d'activation g√©n√©r√©es")
            
            # Fragmenter image
            fragments = self._create_fragments(image)
            total_fragments = len(fragments)
            print(f"üß© DEBUG: {total_fragments} fragments cr√©√©s")
            
            # Sauvegarder fragments avec debug
            saved_count = 0
            for fragment_name, fragment in fragments.items():
                try:
                    self._save_encrypted_fragment_debug(fragment_name, fragment)
                    saved_count += 1
                    if saved_count % 100 == 0:  # Log tous les 100 fragments
                        print(f"üíæ DEBUG: {saved_count}/{total_fragments} fragments sauv√©s...")
                except Exception as e:
                    print(f"‚ùå DEBUG: Erreur sauvegarde fragment {fragment_name}: {e}")
                    raise
            
            print(f"‚úÖ DEBUG: Tous les fragments sauv√©s ({saved_count} total)")
            
            # Cr√©er configuration
            image_hash = hashlib.sha256(image.tobytes()).hexdigest()
            self.config = UrnConfig(
                image_hash=image_hash,
                total_fragments=total_fragments,
                image_dimensions=image.size,
                creation_time=time.time(),
                authorized_node=authorized_node
            )
            
            # Sauvegarder config
            self._save_config_debug()
            
            # Pr√©parer premier fragment pour activation
            first_fragment_name = next(iter(fragments.keys()))
            first_fragment = fragments[first_fragment_name]
            
            print(f"üéØ DEBUG: Premier fragment: {first_fragment_name}")
            
            return {
                "urn_id": str(self.urn_dir.name),
                "total_fragments": total_fragments,
                "activation_public_key": base64.b64encode(
                    self.activation_public_key.public_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PublicFormat.SubjectPublicKeyInfo
                    )
                ).decode(),
                "first_fragment_name": first_fragment_name,
                "first_decrypt_key": base64.b64encode(first_fragment.next_decrypt_key).decode()
            }
            
        except Exception as e:
            print(f"üí• DEBUG: ERREUR CRITIQUE dans burn_image: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    def _save_encrypted_fragment_debug(self, fragment_name: str, fragment: AshFragment):
        """Sauvegarde avec debug d√©taill√©"""
        try:
            print(f"üíæ DEBUG: Sauvegarde fragment {fragment_name}")
            
            # S√©rialiser fragment
            fragment_data = asdict(fragment)
            print(f"üìã DEBUG: Fragment data keys: {fragment_data.keys()}")
            
            # Encoder bytes en base64
            if isinstance(fragment_data['next_decrypt_key'], bytes):
                fragment_data['next_decrypt_key'] = base64.b64encode(fragment_data['next_decrypt_key']).decode()
                print("üîÑ DEBUG: Cl√© convertie en base64")
            
            fragment_json = json.dumps(fragment_data)
            print(f"üìÑ DEBUG: JSON fragment: {len(fragment_json)} chars")
            
            # Crypter
            fragment_key = self._derive_fragment_key(fragment_name)
            cipher = Fernet(fragment_key)
            encrypted_data = cipher.encrypt(fragment_json.encode())
            print(f"üîí DEBUG: Fragment crypt√©: {len(encrypted_data)} bytes")
            
            # Sauvegarder
            fragment_path = self.urn_dir / fragment_name
            print(f"üíæ DEBUG: Sauvegarde vers: {fragment_path}")
            
            with open(fragment_path, 'wb') as f:
                f.write(encrypted_data)
            
            # V√©rifier sauvegarde
            if fragment_path.exists():
                file_size = os.path.getsize(fragment_path)
                print(f"‚úÖ DEBUG: Fragment sauv√©! Taille: {file_size} bytes")
                self.fragments_map[fragment_name] = str(fragment_path)
            else:
                print(f"‚ùå DEBUG: Fichier non cr√©√©: {fragment_path}")
                
        except Exception as e:
            print(f"üí• DEBUG: Erreur sauvegarde fragment {fragment_name}: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    def _save_config_debug(self):
        """Sauvegarde config avec debug"""
        try:
            config_path = self.urn_dir / "urn_config.json"
            config_data = asdict(self.config)
            
            print(f"‚öôÔ∏è DEBUG: Sauvegarde config vers: {config_path}")
            with open(config_path, 'w') as f:
                json.dump(config_data, f, indent=2)
            
            if config_path.exists():
                print(f"‚úÖ DEBUG: Config sauv√©e! Taille: {os.path.getsize(config_path)} bytes")
            
        except Exception as e:
            print(f"‚ùå DEBUG: Erreur sauvegarde config: {e}")
            raise
    
    def _generate_activation_keys(self):
        """G√©n√©ration cl√©s asym√©triques"""
        self.activation_private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        self.activation_public_key = self.activation_private_key.public_key()
    
    def _create_fragments(self, image: Image.Image) -> Dict[str, AshFragment]:
        """Cr√©ation fragments avec noms al√©atoires"""
        fragments = {}
        pixels = np.array(image)
        height, width = pixels.shape[:2]
        
        # Cr√©er cha√Æne de fragments randomis√©e
        all_positions = [(x, y) for y in range(height) for x in range(width)]
        
        print(f"üé≤ DEBUG: M√©lange {len(all_positions)} positions...")
        
        # Cr√©er fragments avec cha√Ænage
        for i, (x, y) in enumerate(all_positions):
            fragment_name = f"ash_{secrets.token_hex(16)}.fragment"
            
            # D√©terminer fragment suivant
            if i < len(all_positions) - 1:
                next_fragment_name = f"ash_{secrets.token_hex(16)}.fragment"
            else:
                next_fragment_name = "END_OF_CHAIN"
            
            # G√©n√©rer cl√© pour d√©chiffrer le suivant
            next_key = os.urandom(32)
            
            # Cr√©er fragment
            fragment = AshFragment(
                color_rgb=tuple(pixels[y, x][:3].astype(int)),
                position=(x, y),
                next_fragment_name=next_fragment_name,
                next_decrypt_key=next_key,
                creation_timestamp=time.time()
            )
            
            fragments[fragment_name] = fragment
            
            if i > 0 and i % 1000 == 0:
                print(f"üß© DEBUG: {i}/{len(all_positions)} fragments cr√©√©s...")
        
        return fragments
    
    def _derive_fragment_key(self, fragment_name: str) -> bytes:
        """D√©rivation cl√© fragment"""
        key_material = f"fragment_{fragment_name}_{self.config.image_hash if self.config else 'temp'}"
        digest = hashlib.sha256(key_material.encode()).digest()
        return base64.urlsafe_b64encode(digest)
    
    def list_directory_contents(self):
        """Debug: lister le contenu du r√©pertoire"""
        print(f"\nüìÇ DEBUG: Contenu de {self.urn_dir}:")
        try:
            if self.urn_dir.exists():
                items = list(self.urn_dir.iterdir())
                print(f"üìä DEBUG: {len(items)} √©l√©ments trouv√©s")
                for item in items:
                    if item.is_file():
                        size = os.path.getsize(item)
                        print(f"  üìÑ {item.name} ({size} bytes)")
                    else:
                        print(f"  üìÅ {item.name}/")
            else:
                print("‚ùå DEBUG: R√©pertoire n'existe pas!")
        except Exception as e:
            print(f"‚ùå DEBUG: Erreur listage: {e}")

def demo_urn_debug():
    """Demo avec debug complet"""
    print("üî•ü¶Ö SYST√àME URN - DEBUG COMPLET")
    print("="*50)
    
    # Initialiser syst√®me avec debug
    urn_system = PhantomUrnDebug("./demo_urns_debug")
    
    # Cr√©er image test
    print("\nüé® Cr√©ation image test...")
    test_image = Image.new('RGB', (10, 10))  # Image tr√®s petite pour debug
    # Remplir avec des couleurs diff√©rentes
    pixels = np.random.randint(0, 255, (10, 10, 3), dtype=np.uint8)
    test_image = Image.fromarray(pixels)
    test_image.save("test_debug_image.png")
    print("‚úÖ Image test cr√©√©e: test_debug_image.png")
    
    # Test combustion avec debug
    print("\nüî• Phase BURN avec debug...")
    try:
        burn_result = urn_system.burn_image("test_debug_image.png", "node_debug")
        print("\n‚úÖ COMBUSTION R√âUSSIE!")
        print(f"URN ID: {burn_result['urn_id']}")
        print(f"Fragments: {burn_result['total_fragments']}")
    except Exception as e:
        print(f"\nüí• √âCHEC COMBUSTION: {e}")
        import traceback
        traceback.print_exc()
    
    # V√©rifier contenu r√©pertoire
    urn_system.list_directory_contents()
    
    # Nettoyage
    if os.path.exists("test_debug_image.png"):
        os.unlink("test_debug_image.png")

if __name__ == "__main__":
    demo_urn_debug()